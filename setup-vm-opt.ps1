## VOLT - VM Unsafe Optimization
Write-Host "`n  VOLT - Applying unsafe optimizations...`n" -ForegroundColor Cyan
$mod_rs = @'
pub mod value;
pub mod compiler;

use self::value::*;
use self::compiler::*;

const STACK_MAX: usize = 512;
const FRAME_MAX: usize = 128;

#[derive(Clone, Copy)]
struct CallFrame { fn_idx: usize, ip: usize, slot: usize }

pub struct VM {
    stack: [Value; STACK_MAX],
    sp: usize,
    frames: [CallFrame; FRAME_MAX],
    fc: usize,
    functions: Vec<Function>,
    struct_defs: Vec<StructDef>,
    heap: Heap,
}

impl VM {
    pub fn new(c: Compiler) -> Self {
        VM {
            stack: [Value::NIL; STACK_MAX], sp: 0,
            frames: [CallFrame { fn_idx: 0, ip: 0, slot: 0 }; FRAME_MAX], fc: 1,
            functions: c.functions, struct_defs: c.struct_defs, heap: c.heap,
        }
    }

    fn get_field_val(&self, obj: Value, name_val: Value) -> Value {
        if !obj.is_obj() { return Value::NIL; }
        match self.heap.get(obj.as_obj()) {
            Obj::Struct { type_idx, fields } => {
                if let Obj::Str(s) = self.heap.get(name_val.as_obj()) {
                    let sdef = &self.struct_defs[*type_idx as usize];
                    if let Some(pos) = sdef.field_names.iter().position(|f| f == s) {
                        return fields[pos];
                    }
                }
                Value::NIL
            }
            _ => Value::NIL,
        }
    }

    fn find_method(&self, obj: Value, name: &str) -> Option<usize> {
        if !obj.is_obj() { return None; }
        if let Obj::Struct { type_idx, .. } = self.heap.get(obj.as_obj()) {
            return self.struct_defs[*type_idx as usize].methods.get(name).copied();
        }
        None
    }

    pub fn run(&mut self) -> Result<(), String> {
        // Safety: bytecode generated by our compiler guarantees valid
        // stack indices, code offsets, constant indices, and frame bounds.
        unsafe { self.dispatch() }
    }

    #[inline(never)]
    unsafe fn dispatch(&mut self) -> Result<(), String> {
        loop {
            let fc = self.fc;
            let frame = self.frames.get_unchecked(fc - 1);
            let fi = frame.fn_idx;
            let ip = frame.ip;
            let slot = frame.slot;
            let func = self.functions.get_unchecked(fi);
            let code = func.code.as_ptr();
            let op = *code.add(ip);

            match op {
                // ── Constants & Locals ──────────────
                OP_CONSTANT => {
                    let idx = *code.add(ip + 1) as usize;
                    *self.stack.get_unchecked_mut(self.sp) = *func.constants.get_unchecked(idx);
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }
                OP_NIL => {
                    *self.stack.get_unchecked_mut(self.sp) = Value::NIL;
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_TRUE => {
                    *self.stack.get_unchecked_mut(self.sp) = Value::TRUE;
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_FALSE => {
                    *self.stack.get_unchecked_mut(self.sp) = Value::FALSE;
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_POP => {
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_GET_LOCAL => {
                    let idx = *code.add(ip + 1) as usize;
                    *self.stack.get_unchecked_mut(self.sp) = *self.stack.get_unchecked(slot + idx);
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }
                OP_SET_LOCAL => {
                    let idx = *code.add(ip + 1) as usize;
                    self.sp -= 1;
                    *self.stack.get_unchecked_mut(slot + idx) = *self.stack.get_unchecked(self.sp);
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }

                // ── Arithmetic (in-place on stack) ──
                OP_ADD => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a + b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_SUB => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a - b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_MUL => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a * b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_DIV => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a / b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_MOD => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a % b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_NEGATE => {
                    let v = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 1) = Value::number(-v);
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_NOT => {
                    let v = *self.stack.get_unchecked(self.sp - 1);
                    *self.stack.get_unchecked_mut(self.sp - 1) = Value::boolean(!v.is_truthy());
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }

                // ── Comparison (in-place) ───────────
                OP_EQ => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).0;
                    let a = (*self.stack.get_unchecked(self.sp - 2)).0;
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a == b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_NEQ => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).0;
                    let a = (*self.stack.get_unchecked(self.sp - 2)).0;
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a != b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_LT => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a < b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_GT => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a > b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_LTE => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a <= b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_GTE => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::boolean(a >= b);
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }

                // ── Control flow ────────────────────
                OP_JUMP => {
                    let hi = *code.add(ip + 1) as usize;
                    let lo = *code.add(ip + 2) as usize;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 3 + ((hi << 8) | lo);
                }
                OP_LOOP => {
                    let hi = *code.add(ip + 1) as usize;
                    let lo = *code.add(ip + 2) as usize;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 3 - ((hi << 8) | lo);
                }
                OP_JUMP_IF_FALSE => {
                    let hi = *code.add(ip + 1) as usize;
                    let lo = *code.add(ip + 2) as usize;
                    let offset = (hi << 8) | lo;
                    let val = *self.stack.get_unchecked(self.sp - 1);
                    // Fast: check FALSE/NIL directly (most common in conditionals)
                    let falsy = val.0 == Value::FALSE.0 || val.0 == Value::NIL.0
                        || (val.is_number() && val.as_number() == 0.0);
                    self.frames.get_unchecked_mut(fc - 1).ip =
                        if falsy { ip + 3 + offset } else { ip + 3 };
                }

                // ── Functions ───────────────────────
                OP_CALL => {
                    let callee = *code.add(ip + 1) as usize;
                    let argc = *code.add(ip + 2) as usize;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 3;
                    let f = self.frames.get_unchecked_mut(fc);
                    f.fn_idx = callee;
                    f.ip = 0;
                    f.slot = self.sp - argc;
                    self.fc += 1;
                    continue;
                }
                OP_RETURN => {
                    self.sp -= 1;
                    let result = *self.stack.get_unchecked(self.sp);
                    self.sp = slot;
                    self.fc -= 1;
                    if self.fc == 0 { return Ok(()); }
                    *self.stack.get_unchecked_mut(self.sp) = result;
                    self.sp += 1;
                    continue;
                }

                // ── Builtins ────────────────────────
                OP_PRINT => {
                    let argc = *code.add(ip + 1) as usize;
                    let base = self.sp - argc;
                    let mut parts = Vec::with_capacity(argc);
                    for i in 0..argc {
                        parts.push((*self.stack.get_unchecked(base + i)).display(&self.heap));
                    }
                    self.sp = base;
                    println!("{}", parts.join(" "));
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }
                OP_SQRT => {
                    let v = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 1) = Value::number(v.sqrt());
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_ABS => {
                    let v = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 1) = Value::number(v.abs());
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_LEN => {
                    let v = *self.stack.get_unchecked(self.sp - 1);
                    let len = if v.is_obj() {
                        match self.heap.get(v.as_obj()) {
                            Obj::Array(items) => items.len(),
                            Obj::Str(s) => s.len(),
                            _ => 0,
                        }
                    } else { 0 };
                    *self.stack.get_unchecked_mut(self.sp - 1) = Value::number(len as f64);
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_MIN => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a.min(b));
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_MAX => {
                    let b = (*self.stack.get_unchecked(self.sp - 1)).as_number();
                    let a = (*self.stack.get_unchecked(self.sp - 2)).as_number();
                    *self.stack.get_unchecked_mut(self.sp - 2) = Value::number(a.max(b));
                    self.sp -= 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }

                // ── Data structures ─────────────────
                OP_NEW_ARRAY => {
                    let count = *code.add(ip + 1) as usize;
                    let base = self.sp - count;
                    let mut items = Vec::with_capacity(count);
                    for i in 0..count { items.push(*self.stack.get_unchecked(base + i)); }
                    self.sp = base;
                    let idx = self.heap.alloc(Obj::Array(items));
                    *self.stack.get_unchecked_mut(self.sp) = Value::obj(idx);
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }
                OP_GET_INDEX => {
                    let idx = (*self.stack.get_unchecked(self.sp - 1)).as_number() as usize;
                    let arr = *self.stack.get_unchecked(self.sp - 2);
                    self.sp -= 1;
                    let result = if arr.is_obj() {
                        if let Obj::Array(items) = self.heap.get(arr.as_obj()) {
                            if idx < items.len() { items[idx] } else { Value::NIL }
                        } else { Value::NIL }
                    } else { Value::NIL };
                    *self.stack.get_unchecked_mut(self.sp - 1) = result;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 1;
                }
                OP_NEW_STRUCT => {
                    let type_idx = *code.add(ip + 1);
                    let argc = *code.add(ip + 2) as usize;
                    let base = self.sp - argc;
                    let mut fields = Vec::with_capacity(argc);
                    for i in 0..argc { fields.push(*self.stack.get_unchecked(base + i)); }
                    self.sp = base;
                    let idx = self.heap.alloc(Obj::Struct { type_idx: type_idx as u16, fields });
                    *self.stack.get_unchecked_mut(self.sp) = Value::obj(idx);
                    self.sp += 1;
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 3;
                }
                OP_GET_FIELD => {
                    let ci = *code.add(ip + 1) as usize;
                    let name_val = *func.constants.get_unchecked(ci);
                    let obj = *self.stack.get_unchecked(self.sp - 1);
                    *self.stack.get_unchecked_mut(self.sp - 1) = self.get_field_val(obj, name_val);
                    self.frames.get_unchecked_mut(fc - 1).ip = ip + 2;
                }
                OP_INVOKE => {
                    let ci = *code.add(ip + 1) as usize;
                    let argc = *code.add(ip + 2) as usize;
                    let name_val = *func.constants.get_unchecked(ci);
                    let method_name = match self.heap.get(name_val.as_obj()) {
                        Obj::Str(s) => s.clone(),
                        _ => return Err("invalid method".into()),
                    };
                    let obj = *self.stack.get_unchecked(self.sp - argc - 1);
                    match self.find_method(obj, &method_name) {
                        Some(method_fi) => {
                            self.frames.get_unchecked_mut(fc - 1).ip = ip + 3;
                            let f = self.frames.get_unchecked_mut(fc);
                            f.fn_idx = method_fi;
                            f.ip = 0;
                            f.slot = self.sp - argc - 1;
                            self.fc += 1;
                            continue;
                        }
                        None => return Err(format!("method '{}' not found", method_name)),
                    }
                }
                _ => return Err(format!("unknown opcode {}", op)),
            }
        }
    }
}

'@

[System.IO.File]::WriteAllText("$PWD\src\vm\mod.rs", $mod_rs)
Write-Host "  [OK] src\vm\mod.rs (unsafe hot paths)" -ForegroundColor Green
Write-Host "`n  Rebuild & benchmark:" -ForegroundColor Cyan
Write-Host "    cargo build --release" -ForegroundColor Yellow
Write-Host "    .\target\release\volt.exe run tests\programs\fibonacci.volt" -ForegroundColor Yellow
Write-Host ""
